# -*- coding: utf-8 -*-
"""
Concrete TensorInterface implementation using numpy
"""
from __future__ import print_function, division
from tensors import EinsteinSummationError, EinsteinSummationWarning
from tensors.abstract import TensorInterfaceBase
try:
    # TODO check for a minimum numpy version
    import numpy as np
except ImportError:
    raise ImportError("numpy is required for the numpy interface")
import atexit
from warnings import warn

@atexit.register
def _check_released():
    if len(NumPyInterface._arrays) > 0:
        warn("{} tensors generated by NumPyInterface were"
             " not released".format(len(NumPyInterface._arrays)),
            EinsteinSummationWarning
        )

class NumPyInterface(TensorInterfaceBase):
    """
    Concrete TensorInterface implementation using numpy
    """

    #--------------------------------------------------------------------------------#

    #region | Private Class Attributes                                                  {{{1 |

    _arrays = []

    #endregion }}}1

    #--------------------------------------------------------------------------------#

    #region | Class Methods                                                             {{{1 |

    @classmethod
    def create_tensor(cls, shape):
        rv = cls(shape)
        cls._arrays.append(rv)
        return rv

    @classmethod
    def release_tensor(cls, obj):
        if obj in cls._arrays:
            cls._arrays.pop(cls._arrays.index(obj))
        else:
            raise EinsteinSummationError("released tensor was never allocated")

    @classmethod
    def dot_product(cls, *args):
        return np.einsum(
            ",".join(args[1::2]),
            *[arg._array for arg in args[::2]]
        )

    #endregion }}}1

    #--------------------------------------------------------------------------------#

    #region | Private Attributes                                                        {{{1 |

    _array = None
    """
    The underlying numpy.ndarray
    """

    #_view_of = None
    #"""
    #The concrete tensor that `self` is a view of, or `None` if `self` is not a view.
    #"""

    #endregion }}}1

    #--------------------------------------------------------------------------------#

    #region | Initialization                                                            {{{1 |

    def __init__(self, shape=None, array=None):
        if shape is not None:
            self._array = np.ndarray(shape=shape)
        elif array is not None:
            self._array = array
        else:
            raise TypeError("invalid arguments")

    #endregion }}}1

    #--------------------------------------------------------------------------------#

    #region | Special Methods                                                           {{{1 |

    #def __array__(self):
    #    """
    #    NumPy implicit array casting
    #    """
    #    return self._array

    #endregion }}}1

    #--------------------------------------------------------------------------------#

    #region | Properties                                                                {{{1 |

    @property
    def shape(self):
        return self._array.shape

    #endregion }}}1

    #--------------------------------------------------------------------------------#

    #region | Methods                                                                   {{{1 |

    def contract_into(self, alpha, a, a_indices, b, b_indices, beta, c_indices):
        subscripts = a_indices + "," + b_indices + "->" + c_indices
        if beta == 0:
            # special case of beta being exactly 0; just overwrite data
            np.einsum(subscripts, a._array, b._array, out=self._array)
            self._array *= alpha
        else:
            # need to make a temporary copy of result to add; np.einsum() does this already
            self._array[...] = alpha * np.einsum(subscripts, a._array, b._array) + beta * self._array

    def add_into(self, alpha, a, beta):
        if a is 1:
            self._array[...] += alpha
            self._array[...] *= beta
        if beta == 0:
            # special case of beta being exactly 0; just overwrite data
            self._array[...] = alpha * a._array
        else:
            self._array[...] = alpha * a._array + beta * self._array

    def sort_into(self, old, new_axes):
        # this kind of feels backwards...
        self._array[...] = np.transpose(old._array, axes=list(new_axes))

    def subtensor_view(self, *args):
        return type(self)(array=self._array[args])

    def get_element(self, indices):
        return self._array[indices]

    def set_element(self, indices, value):
        self._array[indices] = value

    def internal_dot(self, alpha, indices):
        return alpha * np.einsum(indices, self._array)

    def scale(self, alpha):
        self._array *= alpha

    def copy_into(self, other):
        self._array[...] = other._array
    #endregion }}}1

    #--------------------------------------------------------------------------------#

    #region | Private Methods                                                           {{{1 |

    #def _tmp_copy(self):
    #    rv = type(self).create_tensor(self.shape)
    #    rv._array[...] = self._array
    #    return rv

    #def _overlaps_with(self, other):
    #    pass

    #endregion }}}1

    #--------------------------------------------------------------------------------#

    pass
    # end class NumPyInterface




